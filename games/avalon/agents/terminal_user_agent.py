# -*- coding: utf-8 -*-
"""Terminal User Agent that prints all observed messages."""
from typing import Any, Type, Optional

from pydantic import BaseModel

from agentscope.agent import UserAgent
from agentscope.message import Msg
from agentscope.memory import InMemoryMemory, MemoryBase

from games.avalon.utils import Parser


class TerminalUserAgent(UserAgent):
    """User Agent that prints all observed messages to terminal.
    
    This class extends UserAgent to automatically print all messages
    observed during the game, making it easier for users to see what's
    happening in the game. It also maintains a memory similar to ThinkingReActAgent.
    """
    
    def __init__(
        self,
        name: str,
        memory: Optional[MemoryBase] = None,
    ) -> None:
        """Initialize TerminalUserAgent.
        
        Args:
            name: Agent name.
            memory: Memory instance. If None, will create InMemoryMemory.
        """
        super().__init__(name=name)
        self.memory = memory if memory is not None else InMemoryMemory()
    
    async def reply(
        self,
        msg: Msg | list[Msg] | None = None,
        structured_model: Type[BaseModel] | None = None,
    ) -> Msg:
        """Receive input message(s) and generate a reply message from the user.
        
        This method extends the parent's reply to also print the user's input
        and save messages to log.
        
        Args:
            msg: The message(s) to be replied. If None, the agent will wait
                for user input.
            structured_model: A child class of pydantic.BaseModel that defines
                the structured output format.
        
        Returns:
            The reply message generated by the user.
        """
        # Save input message to memory if provided
        if msg is not None:
            if isinstance(msg, Msg):
                await self.memory.add(msg)
            elif isinstance(msg, list):
                for m in msg:
                    if isinstance(m, Msg):
                        await self.memory.add(m)
        
        # Get the input from the specified input method
        input_data = await self._input_method(
            agent_id=self.id,
            agent_name=self.name,
            structured_model=structured_model,
        )
        
        blocks_input = input_data.blocks_input
        if (
            blocks_input
            and len(blocks_input) == 1
            and blocks_input[0].get("type") == "text"
        ):
            # Turn blocks_input into a string if only one text block exists
            blocks_input = blocks_input[0].get("text")
        
        # Print user input
        input_content = Parser.extract_text_from_content(blocks_input)
        print("-" * 70)
        print(input_content)
        print("-" * 70)
        
        # Create reply message
        reply_msg = Msg(
            self.name,
            content=blocks_input,
            role="user",
            metadata=input_data.structured_input,
        )
        
        # Save reply message to memory
        await self.memory.add(reply_msg)
        
        return reply_msg
    
    async def observe(self, msg: Msg | list[Msg] | None) -> None:
        """Observe messages and print them to terminal.
        
        Also saves observed messages to log.
        
        Args:
            msg: Message(s) to observe. Can be a single Msg, a list of Msg,
                 or None.
        """
        if msg is None:
            return
        
        # Save messages to memory
        if isinstance(msg, Msg):
            await self.memory.add(msg)
        elif isinstance(msg, list):
            for m in msg:
                if isinstance(m, Msg):
                    await self.memory.add(m)
        
        # Handle single message
        if isinstance(msg, Msg):
            content = Parser.extract_text_from_content(msg.content)
            print("-" * 70)
            print(f"{msg.name}: {content}")
            print("-" * 70)
        
        # Handle list of messages
        elif isinstance(msg, list):
            if not msg:
                return
            print("-" * 70)
            for m in msg:
                if isinstance(m, Msg):
                    content = Parser.extract_text_from_content(m.content)
                    print(f"{m.name}: {content}")
            print("-" * 70)
        
        # Call parent observe to maintain normal behavior
        await super().observe(msg)
    

